import collections.abc
import datetime
import functools
import logging
import tarfile

import ci.log
import cnudie.iter
import cnudie.retrieve
import delivery.client
import oci.client
import oci.model
import ocm

import k8s.logging
import k8s.util
import malware.scan
import odg.extensions_cfg
import odg.findings
import odg.model
import odg.util
import paths
import secret_mgmt


logger = logging.getLogger(__name__)
ci.log.configure_default_logging()
k8s.logging.configure_kubernetes_logging()


def scan_resource(
    resource_node: cnudie.iter.ResourceNode,
    malware_cfg: odg.findings.Finding,
    oci_client: oci.client.Client,
    aws_secret_name: str | None,
    secret_factory: secret_mgmt.SecretFactory,
) -> collections.abc.Generator[odg.model.ClamAVMalwareFinding, None, None]:
    resource: ocm.Resource = resource_node.resource

    if resource.access.type is ocm.AccessType.OCI_REGISTRY:
        results = malware.scan.scan_oci_image(
            image_reference=resource.access.imageReference,
            oci_client=oci_client,
            malware_cfg=malware_cfg,
        )

    elif resource.access.type is ocm.AccessType.S3:
        if not aws_secret_name:
            raise ValueError('"aws_secret_name" must be configured for resources stored in S3')

        logger.info(f'using AWS secret element "{aws_secret_name}"')
        aws_secret = secret_factory.aws(aws_secret_name)
        s3_client = aws_secret.session.resource('s3')

        if (
            not resource.type.startswith('application/tar')
            and not resource.type.startswith('application/x-tar')
        ):
            raise NotImplementedError(resource.type)

        fileobj = s3_client.Object(
            resource.access.bucketName,
            resource.access.objectKey,
        ).get()['Body']

        tf = tarfile.open(fileobj=fileobj, mode='r|*')
        results = malware.scan.scan_tarfile(
            malware_cfg=malware_cfg,
            tf=tf,
            context=f'{resource.access.bucketName}|{resource.access.objectKey}',
        )

    elif resource.access.type is ocm.AccessType.LOCAL_BLOB:
        if resource.access.globalAccess:
            image_reference = resource.access.globalAccess.ref
            digest = resource.access.globalAccess.digest
            size = resource.access.globalAccess.size
        else:
            ocm_repo = resource_node.component.current_ocm_repo
            image_reference = ocm_repo.component_oci_ref(resource_node.component.name)
            digest = resource.access.localReference
            size = resource.access.size

        results = malware.scan.scan_oci_blob(
            blob_reference=oci.model.OciBlobRef(
                digest=digest,
                mediaType=resource.access.mediaType,
                size=size,
            ),
            image_reference=image_reference,
            oci_client=oci_client,
            malware_cfg=malware_cfg,
        )

    else:
        raise RuntimeError(resource.access.type) # we filtered supported access types already earlier

    return results


def _iter_clamav_malware_findings(
    findings: collections.abc.Iterable[odg.model.ClamAVMalwareFinding],
    resource_node: cnudie.iter.ResourceNode,
    malware_cfg: odg.findings.Finding,
) -> collections.abc.Generator[odg.model.ArtefactMetadata, None, None]:
    discovery_date = datetime.date.today()
    now = datetime.datetime.now()

    artefact_ref = odg.model.component_artefact_id_from_ocm(
        component=resource_node.component,
        artefact=resource_node.artefact,
    )

    meta = odg.model.Metadata(
        datasource=odg.model.Datasource.CLAMAV,
        type=odg.model.Datatype.MALWARE_FINDING,
        creation_date=now,
        last_update=now,
    )

    for finding in findings:
        categorisation = malware_cfg.categorisation_by_id(finding.severity)

        yield odg.model.ArtefactMetadata(
            artefact=artefact_ref,
            meta=meta,
            data=finding,
            discovery_date=discovery_date,
            allowed_processing_time=categorisation.allowed_processing_time_raw,
        )


def scan_and_upload(
    artefact: odg.model.ComponentArtefactId,
    extension_cfg: odg.extensions_cfg.ClamAVConfig,
    malware_cfg: odg.findings.Finding | None,
    component_descriptor_lookup: cnudie.retrieve.ComponentDescriptorLookupById,
    delivery_client: delivery.client.DeliveryServiceClient,
    oci_client: oci.client.Client,
    secret_factory: secret_mgmt.SecretFactory,
    **kwargs,
):
    logger.info(f'scanning {artefact}')

    retrieve_malware_findings = malware_cfg and malware_cfg.matches(artefact)

    if not retrieve_malware_findings:
        logger.info('Malware findings are filtered out for this artefact, skipping...')
        return

    if not extension_cfg.is_supported(artefact_kind=artefact.artefact_kind):
        if extension_cfg.on_unsupported is odg.extensions_cfg.WarningVerbosities.FAIL:
            raise TypeError(
                f'{artefact.artefact_kind} is not supported by the ClamAV extension, maybe the '
                'filter configurations have to be adjusted to filter out this artefact kind'
            )
        return

    resource_node = k8s.util.get_ocm_node(
        component_descriptor_lookup=component_descriptor_lookup,
        artefact=artefact,
    )
    access_type = resource_node.resource.access.type
    resource_type = resource_node.resource.type

    if not extension_cfg.is_supported(
        access_type=access_type,
        artefact_type=resource_type,
    ):
        if extension_cfg.on_unsupported is odg.extensions_cfg.WarningVerbosities.FAIL:
            raise TypeError(
                f'{access_type=} with {resource_type=} is not supported by the ClamAV extension, '
                'maybe the filter configurations have to be adjusted to filter out these types'
            )
        return

    mapping = extension_cfg.mapping(artefact.component_name)

    result = scan_resource(
        resource_node=resource_node,
        malware_cfg=malware_cfg,
        oci_client=oci_client,
        aws_secret_name=mapping.aws_secret_name,
        secret_factory=secret_factory,
    )

    scan_info = odg.model.artefact_scan_info(
        artefact_node=resource_node,
        datasource=odg.model.Datasource.CLAMAV,
    )

    delivery_client.update_metadata(
        data=list(
            _iter_clamav_malware_findings(
                findings=result,
                resource_node=resource_node,
                malware_cfg=malware_cfg,
            )
        ) + [scan_info]
    )


def main():
    parsed_arguments = odg.util.parse_args()

    if not (findings_cfg_path := parsed_arguments.findings_cfg_path):
        findings_cfg_path = paths.findings_cfg_path()

    malware_cfg = odg.findings.Finding.from_file(
        path=findings_cfg_path,
        finding_type=odg.model.Datatype.MALWARE_FINDING,
    )

    scan_and_upload_callback = functools.partial(
        scan_and_upload,
        malware_cfg=malware_cfg,
    )

    odg.util.process_backlog_items(
        parsed_arguments=parsed_arguments,
        service=odg.extensions_cfg.Services.CLAMAV,
        callback=scan_and_upload_callback,
    )


if __name__ == '__main__':
    main()
