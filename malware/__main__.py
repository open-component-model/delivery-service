import argparse
import atexit
import collections.abc
import datetime
import logging
import os
import signal
import sys
import tarfile
import time

import ci.log
import cnudie.iter
import cnudie.retrieve
import delivery.client
import dso.model
import oci.client
import oci.model
import ocm

import consts
import ctx_util
import k8s.backlog
import k8s.logging
import k8s.model
import k8s.util
import lookups
import malware.clamav
import malware.scan
import odg.extensions_cfg
import odg.findings
import paths
import secret_mgmt


logger = logging.getLogger(__name__)
ci.log.configure_default_logging()
k8s.logging.configure_kubernetes_logging()

own_dir = os.path.abspath(os.path.dirname(__file__))
default_cache_dir = os.path.join(own_dir, '.cache')

ready_to_terminate = True
wants_to_terminate = False


def handle_termination_signal(*args):
    global wants_to_terminate

    # also terminate if > 1 termination signals were received
    if ready_to_terminate or wants_to_terminate:
        sys.exit(0)

    # grace period to finish current scan is defined in the replica set
    # after this period, the scan will be terminated anyways by k8s means
    logger.info('termination signal received, will try to finish current scan and then exit')
    wants_to_terminate = True


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--k8s-cfg-name',
        help='specify kubernetes cluster to interact with',
        default=os.environ.get('K8S_CFG_NAME'),
    )
    parser.add_argument(
        '--kubeconfig',
        help='''
            specify kubernetes cluster to interact with extensions (and logs); if both
            `k8s-cfg-name` and `kubeconfig` are set, `k8s-cfg-name` takes precedence
        ''',
    )
    parser.add_argument(
        '--k8s-namespace',
        help='specify kubernetes cluster namespace to interact with',
        default=os.environ.get('K8S_TARGET_NAMESPACE'),
    )
    parser.add_argument(
        '--extensions-cfg-path',
        help='path to the `extensions_cfg.yaml` file that should be used',
    )
    parser.add_argument(
        '--findings-cfg-path',
        help='path to the `findings.yaml` file that should be used',
    )
    parser.add_argument(
        '--delivery-service-url',
        help='''
            specify the url of the delivery service to use instead of the one configured in the
            respective extensions configuration
        ''',
    )
    parser.add_argument('--cache-dir', default=default_cache_dir)

    parsed_arguments = parser.parse_args()

    if not parsed_arguments.k8s_namespace:
        raise ValueError(
            'k8s namespace must be set, either via argument "--k8s-namespace" '
            'or via environment variable "K8S_TARGET_NAMESPACE"'
        )

    return parsed_arguments


def scan_resource(
    resource_node: cnudie.iter.ResourceNode,
    malware_cfg: odg.findings.Finding,
    oci_client: oci.client.Client,
    aws_secret_name: str | None,
    secret_factory: secret_mgmt.SecretFactory,
) -> collections.abc.Generator[dso.model.ClamAVMalwareFinding, None, None]:
    resource: ocm.Resource = resource_node.resource

    if resource.access.type is ocm.AccessType.OCI_REGISTRY:
        results = malware.scan.scan_oci_image(
            image_reference=resource.access.imageReference,
            oci_client=oci_client,
            malware_cfg=malware_cfg,
        )

    elif resource.access.type is ocm.AccessType.S3:
        if not aws_secret_name:
            raise ValueError('"aws_secret_name" must be configured for resources stored in S3')

        logger.info(f'using AWS secret element "{aws_secret_name}"')
        aws_secret = secret_factory.aws(aws_secret_name)
        s3_client = aws_secret.session.resource('s3')

        if (
            not resource.type.startswith('application/tar')
            and not resource.type.startswith('application/x-tar')
        ):
            raise NotImplementedError(resource.type)

        fileobj = s3_client.Object(
            resource.access.bucketName,
            resource.access.objectKey,
        ).get()['Body']

        tf = tarfile.open(fileobj=fileobj, mode='r|*')
        results = malware.scan.scan_tarfile(
            malware_cfg=malware_cfg,
            tf=tf,
            context=f'{resource.access.bucketName}|{resource.access.objectKey}',
        )

    elif resource.access.type is ocm.AccessType.LOCAL_BLOB:
        if resource.access.globalAccess:
            image_reference = resource.access.globalAccess.ref
            digest = resource.access.globalAccess.digest
            size = resource.access.globalAccess.size
        else:
            ocm_repo = resource_node.component.current_ocm_repo
            image_reference = ocm_repo.component_oci_ref(resource_node.component.name)
            digest = resource.access.localReference
            size = resource.access.size

        results = malware.scan.scan_oci_blob(
            blob_reference=oci.model.OciBlobRef(
                digest=digest,
                mediaType=resource.access.mediaType,
                size=size,
            ),
            image_reference=image_reference,
            oci_client=oci_client,
            malware_cfg=malware_cfg,
        )

    else:
        raise RuntimeError(resource.access.type) # we filtered supported access types already earlier

    return results


def _iter_clamav_malware_findings(
    findings: collections.abc.Iterable[dso.model.ClamAVMalwareFinding],
    resource_node: cnudie.iter.ResourceNode,
    malware_cfg: odg.findings.Finding,
    datasource: str = dso.model.Datasource.CLAMAV,
    datatype: str = odg.findings.FindingType.MALWARE,
) -> collections.abc.Generator[dso.model.ArtefactMetadata, None, None]:
    discovery_date = datetime.date.today()
    now = datetime.datetime.now()

    artefact_ref = dso.model.component_artefact_id_from_ocm(
        component=resource_node.component,
        artefact=resource_node.artefact,
    )

    meta = dso.model.Metadata(
        datasource=datasource,
        type=datatype,
        creation_date=now,
        last_update=now,
    )

    for finding in findings:
        categorisation = malware_cfg.categorisation_by_id(finding.severity)

        yield dso.model.ArtefactMetadata(
            artefact=artefact_ref,
            meta=meta,
            data=finding,
            discovery_date=discovery_date,
            allowed_processing_time=categorisation.allowed_processing_time_raw,
        )


def scan_and_upload(
    artefact: dso.model.ComponentArtefactId,
    clamav_cfg: odg.extensions_cfg.ClamAVConfig,
    malware_cfg: odg.findings.Finding | None,
    component_descriptor_lookup: cnudie.retrieve.ComponentDescriptorLookupById,
    delivery_client: delivery.client.DeliveryServiceClient,
    oci_client: oci.client.Client,
    secret_factory: secret_mgmt.SecretFactory,
):
    logger.info(f'scanning {artefact}')

    retrieve_malware_findings = malware_cfg and malware_cfg.matches(artefact)

    if not retrieve_malware_findings:
        logger.info('Malware findings are filtered out for this artefact, skipping...')
        return

    if not clamav_cfg.is_supported(artefact_kind=artefact.artefact_kind):
        if clamav_cfg.on_unsupported is odg.extensions_cfg.WarningVerbosities.FAIL:
            raise TypeError(
                f'{artefact.artefact_kind} is not supported by the ClamAV extension, maybe the '
                'filter configurations have to be adjusted to filter out this artefact kind'
            )
        return

    resource_node = k8s.util.get_ocm_node(
        component_descriptor_lookup=component_descriptor_lookup,
        artefact=artefact,
    )
    access_type = resource_node.resource.access.type
    resource_type = resource_node.resource.type

    if not clamav_cfg.is_supported(
        access_type=access_type,
        artefact_type=resource_type,
    ):
        if clamav_cfg.on_unsupported is odg.extensions_cfg.WarningVerbosities.FAIL:
            raise TypeError(
                f'{access_type=} with {resource_type=} is not supported by the ClamAV extension, '
                'maybe the filter configurations have to be adjusted to filter out these types'
            )
        return

    mapping = clamav_cfg.mapping(artefact.component_name)

    result = scan_resource(
        resource_node=resource_node,
        malware_cfg=malware_cfg,
        oci_client=oci_client,
        aws_secret_name=mapping.aws_secret_name,
        secret_factory=secret_factory,
    )

    scan_info = dso.model.artefact_scan_info(
        artefact_node=resource_node,
        datasource=dso.model.Datasource.CLAMAV,
    )

    delivery_client.update_metadata(
        data=list(
            _iter_clamav_malware_findings(
                findings=result,
                resource_node=resource_node,
                malware_cfg=malware_cfg,
            )
        ) + [scan_info]
    )


def main():
    signal.signal(signal.SIGTERM, handle_termination_signal)
    signal.signal(signal.SIGINT, handle_termination_signal)

    parsed_arguments = parse_args()
    namespace = parsed_arguments.k8s_namespace
    delivery_service_url = parsed_arguments.delivery_service_url

    secret_factory = ctx_util.secret_factory()

    if parsed_arguments.k8s_cfg_name:
        kubernetes_cfg = secret_factory.kubernetes(parsed_arguments.k8s_cfg_name)
        kubernetes_api = k8s.util.kubernetes_api(kubernetes_cfg=kubernetes_cfg)
    else:
        kubernetes_api = k8s.util.kubernetes_api(
            kubeconfig_path=parsed_arguments.kubeconfig,
        )

    k8s.logging.init_logging_thread(
        service=odg.extensions_cfg.Services.CLAMAV,
        namespace=namespace,
        kubernetes_api=kubernetes_api,
    )

    atexit.register(
        k8s.logging.log_to_crd,
        service=odg.extensions_cfg.Services.CLAMAV,
        namespace=namespace,
        kubernetes_api=kubernetes_api,
    )

    if not (extensions_cfg_path := parsed_arguments.extensions_cfg_path):
        extensions_cfg_path = paths.extensions_cfg_path()

    extensions_cfg = odg.extensions_cfg.ExtensionsConfiguration.from_file(extensions_cfg_path)
    clamav_cfg = extensions_cfg.clamav

    if not (findings_cfg_path := parsed_arguments.findings_cfg_path):
        findings_cfg_path = paths.findings_cfg_path()

    malware_cfg = odg.findings.Finding.from_file(
        path=findings_cfg_path,
        finding_type=odg.findings.FindingType.MALWARE,
    )

    if not delivery_service_url:
        delivery_service_url = clamav_cfg.delivery_service_url

    delivery_client = delivery.client.DeliveryServiceClient(
        routes=delivery.client.DeliveryServiceRoutes(
            base_url=delivery_service_url,
        ),
        auth_token_lookup=lookups.github_auth_token_lookup,
    )

    oci_client = lookups.semver_sanitising_oci_client(
        secret_factory=secret_factory,
    )

    component_descriptor_lookup = lookups.init_component_descriptor_lookup(
        cache_dir=parsed_arguments.cache_dir,
        delivery_client=delivery_client,
        oci_client=oci_client,
    )

    global ready_to_terminate
    while not wants_to_terminate:
        ready_to_terminate = False

        backlog_crd = k8s.backlog.get_backlog_crd_and_claim(
            service=odg.extensions_cfg.Services.CLAMAV,
            namespace=namespace,
            kubernetes_api=kubernetes_api,
        )

        if not backlog_crd:
            ready_to_terminate = True
            sleep_interval = consts.BACKLOG_ITEM_SLEEP_INTERVAL_SECONDS
            logger.info(f'no open backlog item found, will sleep for {sleep_interval} sec')
            time.sleep(sleep_interval)
            continue

        name = backlog_crd.get('metadata').get('name')
        logger.info(f'processing backlog item {name}')

        backlog_item = k8s.backlog.BacklogItem.from_dict(
            backlog_item=backlog_crd.get('spec'),
        )

        scan_and_upload(
            artefact=backlog_item.artefact,
            clamav_cfg=clamav_cfg,
            malware_cfg=malware_cfg,
            component_descriptor_lookup=component_descriptor_lookup,
            delivery_client=delivery_client,
            oci_client=oci_client,
            secret_factory=secret_factory,
        )

        k8s.util.delete_custom_resource(
            crd=k8s.model.BacklogItemCrd,
            name=name,
            namespace=namespace,
            kubernetes_api=kubernetes_api,
        )
        logger.info(f'processed and deleted backlog item {name}')


if __name__ == '__main__':
    main()
