import collections.abc
import datetime
import functools
import hashlib
import logging
import os
import socket
import struct
import subprocess
import threading
import time

import dacite

import github.compliance.model
import dso.model

import clamav.model


logger = logging.getLogger(__name__)
CLAMAV_CFG_DEFAULT_PATH = '/etc/clamav/clamd.conf'
CLAMAV_SOCKET_DEFAULT_PATH = '/run/clamav/clamd.sock'


def _read_cfg(
    cfg_name: str,
    clamav_cfg_path: str=CLAMAV_CFG_DEFAULT_PATH,
):
    if not os.path.exists(clamav_cfg_path):
        raise ValueError(f'no cfg file at {clamav_cfg_path=}')

    with open(clamav_cfg_path, 'r') as f:
        for line in f.readlines():
            if not line.startswith(cfg_name):
                continue

            value = line.split(' ', 1)[-1].strip()
            return value

        return None # rather raise?


@functools.cache
def _lookup_clamd_socket(
    default_path: str=CLAMAV_SOCKET_DEFAULT_PATH,
    clamav_cfg_path: str=CLAMAV_CFG_DEFAULT_PATH,
) -> str:
    if os.path.isfile(clamav_cfg_path):
        # explicit configuration should win over default
        if (path := _read_cfg('LocalSocket')):
            return path

    if os.path.exists(default_path):
        return default_path

    raise ValueError('clamd socket not found')


def clamscan_version() -> clamav.model.ClamAVVersionInfo:
    clamscan_output = subprocess.check_output(
        ['clamscan', '--version'],
    ).decode()

    # example output: "ClamAV 0.105.1/26814/Thu Feb 16 08:40:04 2023/n"
    clamav_version, signature_version, signature_date = clamscan_output.strip().split('/')

    # the signature date is in ctime format. Convert to ISO 8601
    signature_date = datetime.datetime.strptime(
        signature_date, r'%a %b %d %H:%M:%S %Y'
    ).isoformat()

    signature_version = int(signature_version)

    return clamav.model.ClamAVVersionInfo(
        clamav_version_str=clamav_version,
        signature_version=signature_version,
        signature_date=signature_date,
    )


def scan(
    data: collections.abc.Iterable[bytes],
    filename: str,
    finding_cls: type[dso.model.OCIMalwareFinding] | type[dso.model.S3MalwareFinding],
    layer_digest: str | None = None,
) -> dso.model.ClamAVMalwareFinding | None:
    sock = socket.socket(
        family=socket.AF_UNIX,
        type=socket.SOCK_STREAM,
    )
    clamav_socket_address = _lookup_clamd_socket()

    sock.connect(clamav_socket_address)
    sock.send(b'zINSTREAM\x00')

    total = 0
    content_hash = hashlib.sha256()

    for chunk in data:
        leng = len(chunk)
        content_hash.update(chunk)
        total += leng

        sock.send(struct.pack(b'!L', leng))
        sock.send(chunk)

    sock.send(struct.pack(b'!L', 0))

    receive_done_time = time.time()

    result = None

    def read_result():
        nonlocal result
        with sock.makefile('r') as f:
            result = f.read()

    reader = threading.Thread(target=read_result)
    reader.start()

    def responder():
        nonlocal result
        nonlocal content_hash

        while True:
            reader.join(timeout=20)
            if reader.is_alive():
                # still waiting for result
                logger.info('sending keep-alive..')
                continue
            break

        sock.close()

        scan_done_time = time.time()
        scan_duration_seconds = scan_done_time - receive_done_time

        def _virus_name_or_none(
            raw_result: str,
        ) -> str | None:
            '''
            extract virus name from clamav result
            "stream: Eicar-Signature FOUND\x00" -> "Eicar-Signature"

            if result indicates no virus, return None
            '''
            result = raw_result \
                .removeprefix('stream: ') \
                .removesuffix('\x00') \
                .removesuffix(' FOUND')

            if result == 'OK':
                return None

            return result

        virus_name_or_none = _virus_name_or_none(result)

        if not virus_name_or_none:
            return

        content_digest = f'sha256:{content_hash.hexdigest()}'

        finding = dacite.from_dict(
            data_class=finding_cls,
            data={
                'content_digest': content_digest,
                'filename': filename,
                'layer_digest': layer_digest,
                'virus_name': virus_name_or_none,
            },
        )

        return dso.model.ClamAVMalwareFinding(
            finding=finding,
            octets_count=total,
            scan_duration_seconds=scan_duration_seconds,
            severity=github.compliance.model.Severity.BLOCKER.name,
        )

    return responder()
