import collections.abc
import datetime
import functools
import hashlib
import logging
import os
import socket
import struct
import subprocess
import threading
import time

import dso.model

import odg.findings


logger = logging.getLogger(__name__)
CLAMAV_CFG_DEFAULT_PATH = '/etc/clamav/clamd.conf'
CLAMAV_SOCKET_DEFAULT_PATH = '/run/clamav/clamd.sock'


def _read_cfg(
    cfg_name: str,
    clamav_cfg_path: str=CLAMAV_CFG_DEFAULT_PATH,
):
    if not os.path.exists(clamav_cfg_path):
        raise ValueError(f'no cfg file at {clamav_cfg_path=}')

    with open(clamav_cfg_path, 'r') as f:
        for line in f.readlines():
            if not line.startswith(cfg_name):
                continue

            value = line.split(' ', 1)[-1].strip()
            return value

        return None # rather raise?


@functools.cache
def _lookup_clamd_socket(
    default_path: str=CLAMAV_SOCKET_DEFAULT_PATH,
    clamav_cfg_path: str=CLAMAV_CFG_DEFAULT_PATH,
) -> str:
    if os.path.isfile(clamav_cfg_path):
        # explicit configuration should win over default
        if (path := _read_cfg('LocalSocket')):
            return path

    if os.path.exists(default_path):
        return default_path

    raise ValueError('clamd socket not found')


def clamscan_version() -> tuple[str]:
    clamscan_output = subprocess.check_output(
        ['freshclam', '--version'],
    ).decode()

    # example output:
    # ClamAV 1.2.2/27315/Sun Jun 23 08:23:58 2024
    clamav_version, signature_version, signature_date = clamscan_output.strip().split('/')

    # the signature date is in ctime format. Convert to ISO 8601
    signature_date = datetime.datetime.strptime(
        signature_date, r'%a %b %d %H:%M:%S %Y'
    ).isoformat()

    signature_version = int(signature_version)

    return clamav_version, signature_version, signature_date


def scan(
    malware_cfg: odg.findings.Finding,
    data: collections.abc.Iterable[bytes],
    filename: str,
    context: str | None=None,
) -> dso.model.ClamAVMalwareFinding | None:
    sock = socket.socket(
        family=socket.AF_UNIX,
        type=socket.SOCK_STREAM,
    )
    clamav_socket_address = _lookup_clamd_socket()

    sock.connect(clamav_socket_address)
    sock.send(b'zINSTREAM\x00')

    total = 0
    content_hash = hashlib.sha256()

    for chunk in data:
        leng = len(chunk)
        content_hash.update(chunk)
        total += leng

        sock.send(struct.pack(b'!L', leng))
        sock.send(chunk)

    sock.send(struct.pack(b'!L', 0))

    receive_done_time = time.time()

    result = None

    def read_result():
        nonlocal result
        with sock.makefile('r') as f:
            result = f.read()

    reader = threading.Thread(target=read_result)
    reader.start()

    def responder():
        while True:
            reader.join(timeout=20)
            if reader.is_alive():
                # still waiting for result
                logger.info('sending keep-alive..')
                continue
            break

        sock.close()

        scan_done_time = time.time()
        scan_duration_seconds = scan_done_time - receive_done_time

        def _malware_or_none(
            raw_result: str,
        ) -> str | None:
            '''
            extract malware name from clamav result
            "stream: Eicar-Signature FOUND\x00" -> "Eicar-Signature"

            if result indicates no malware, return None
            '''
            result = raw_result \
                .removeprefix('stream: ') \
                .removesuffix('\x00') \
                .removesuffix(' FOUND') \
                .removesuffix('\n')

            if result == 'OK':
                return None

            return result

        malware_or_none = _malware_or_none(result)

        if not malware_or_none:
            return

        categorisation = odg.findings.categorise_finding(
            finding_cfg=malware_cfg,
            finding_property=malware_or_none,
        )

        if not categorisation:
            return

        finding = dso.model.MalwareFindingDetails(
            filename=filename,
            content_digest=f'sha256:{content_hash.hexdigest()}',
            malware=malware_or_none,
            context=context,
        )

        clamav_version, signature_version, signature_date = clamscan_version()

        return dso.model.ClamAVMalwareFinding(
            finding=finding,
            octets_count=total,
            scan_duration_seconds=scan_duration_seconds,
            severity=categorisation.id,
            clamav_version=clamav_version,
            signature_version=signature_version,
            freshclam_timestamp=signature_date,
        )

    return responder()
