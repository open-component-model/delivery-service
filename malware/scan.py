import collections.abc
import concurrent.futures
import functools
import logging
import tarfile
import tempfile

import ci.log
import dso.model
import oci.client
import oci.model

import malware.clamav


logger = logging.getLogger(__name__)
ci.log.configure_default_logging()


def scan_tarfile(
    tf: tarfile.TarFile,
    context: str | None=None,
) -> collections.abc.Generator[dso.model.ClamAVMalwareFinding, None, None]:
    for tar_info in tf:
        if not tar_info.isfile():
            continue
        data = tf.extractfile(member=tar_info)

        with tempfile.TemporaryFile() as tmp_file:
            tmp_file.write(data.read())
            tmp_file.seek(0)

            if (scan_result := malware.clamav.scan(
                data=tmp_file,
                filename=tar_info.name,
                context=context,
            )):
                yield scan_result


def _iter_layers(
    image_reference: str | oci.model.OciImageReference,
    oci_client: oci.client.Client,
) -> collections.abc.Generator[oci.model.OciBlobRef, None, None]:
    '''
    yields the flattened layer-blob-references from the given image

    in case of regular ("single") oci-images, this will be said image-manifest's layers.
    in case of an image-list (aka multi-arch), referenced sub-manifests are resolved
    recursively
    '''
    manifest = oci_client.manifest(
        image_reference=image_reference,
        accept=oci.model.MimeTypes.prefer_multiarch,
    )
    if isinstance(manifest, oci.model.OciImageManifest):
        yield from manifest.layers
        return

    if not isinstance(manifest, oci.model.OciImageManifestList):
        raise NotImplementedError(manifest)

    manifest: oci.model.OciImageManifestList
    image_reference = oci.model.OciImageReference.to_image_ref(image_reference)

    for manifest in manifest.manifests:
        sub_manifest_img_ref = f'{image_reference.ref_without_tag}@{manifest.digest}'

        # recurse into (potentially) nested sub-images (typically there should be no nesting)
        yield from _iter_layers(
            image_reference=sub_manifest_img_ref,
            oci_client=oci_client,
        )


def scan_oci_image(
    image_reference: str | oci.model.OciImageReference,
    oci_client: oci.client.Client,
) -> collections.abc.Generator[dso.model.ClamAVMalwareFinding, None, None]:
    layer_blobs = tuple(_iter_layers(image_reference=image_reference, oci_client=oci_client))
    logger.info(f'will scan {len(layer_blobs)} layer blobs')

    scan_func = functools.partial(
        scan_oci_blob,
        image_reference=image_reference,
        oci_client=oci_client,
    )

    if len(layer_blobs) > 1:
        executor = concurrent.futures.ThreadPoolExecutor(max_workers=len(layer_blobs))

        for res in executor.map(scan_func, layer_blobs):
            yield from res
    else:
        yield from scan_func(blob_reference=layer_blobs[0])


def scan_oci_blob(
    blob_reference: oci.model.OciBlobRef,
    image_reference: str | oci.model.OciImageReference,
    oci_client: oci.client.Client,
) -> collections.abc.Generator[dso.model.ClamAVMalwareFinding, None, None]:
    logger.info(f'scanning {blob_reference=}')
    try:
        yield from scan_oci_blob_filewise(
            blob_reference=blob_reference,
            image_reference=image_reference,
            oci_client=oci_client,
        )
    except tarfile.TarError as te:
        logger.warning(f'{image_reference=} {te=} - falling back to layerwise scan')

        yield from scan_oci_blob_layerwise(
            blob_reference=blob_reference,
            image_reference=image_reference,
            oci_client=oci_client,
        )


def scan_oci_blob_filewise(
    blob_reference: oci.model.OciBlobRef,
    image_reference: str | oci.model.OciImageReference,
    oci_client: oci.client.Client,
    chunk_size=8096,
) -> collections.abc.Generator[dso.model.ClamAVMalwareFinding, None, None]:
    blob = oci_client.blob(
        image_reference=image_reference,
        digest=blob_reference.digest,
    )

    # unfortunately, we need a backing tempfile, because we need a seekable filelike-obj for retry
    with tempfile.TemporaryFile() as tmpfh:
        for chunk in blob.iter_content(chunk_size=chunk_size):
            tmpfh.write(chunk)

        tmpfh.seek(0)

        with tarfile.open(
            fileobj=tmpfh,
            mode='r',
        ) as tf:
            for tar_info in tf:
                if not tar_info.isfile():
                    continue

                data = tf.extractfile(member=tar_info)

                if (scan_result := malware.clamav.scan(
                    data=data,
                    filename=tar_info.name,
                    context=blob_reference.digest,
                )):
                    yield scan_result


def scan_oci_blob_layerwise(
    blob_reference: oci.model.OciBlobRef,
    image_reference: str | oci.model.OciImageReference,
    oci_client: oci.client.Client,
) -> collections.abc.Generator[dso.model.ClamAVMalwareFinding, None, None]:
    blob = oci_client.blob(
        image_reference=image_reference,
        digest=blob_reference.digest,
    )

    if (scan_result := malware.clamav.scan(
        data=blob.iter_content(chunk_size=tarfile.RECORDSIZE),
        filename=blob_reference.digest,
    )):
        yield scan_result
